#!/usr/bin/env node

/**
 * Script cross-platform per aggiornare package.json e tsconfig.json
 * basato sulle dipendenze del calendario per tutti i componenti
 * Versione modulare con configurazione esterna
 */

const fs = require("fs");
const path = require("path");
const { execSync } = require("child_process");
const readline = require("readline");

// Import shared logger
const logger = require("./utils/logger");

// Funzione per creare un template vuoto dependencies-config.js
function createEmptyDependenciesConfig(projectRoot) {
  // 1. FONTE PRINCIPALE (per sviluppo del manager)
  let templatePath = path.join(
    __dirname,
    "..",
    "templates",
    "dependencies-config.js"
  );

  // 2. FALLBACK (se l'utente ha rimosso il config)
  if (!fs.existsSync(templatePath)) {
    templatePath = path.join(
      projectRoot,
      "node_modules",
      "@vlad-demchyk",
      "package-manager",
      "templates",
      "dependencies-config.js"
    );
  }

  // 3. FALLBACK ALTERNATIVO
  if (!fs.existsSync(templatePath)) {
    templatePath = path.join(
      projectRoot,
      "node_modules",
      "package-manager",
      "templates",
      "dependencies-config.js"
    );
  }

  const targetPath = path.join(
    projectRoot,
    "package-manager",
    "dependencies-config.js"
  );

  try {
    // Verifichiamo se esiste la cartella package-manager
    const packageManagerDir = path.join(projectRoot, "package-manager");
    if (!fs.existsSync(packageManagerDir)) {
      fs.mkdirSync(packageManagerDir, { recursive: true });
    }

    // Verifichiamo se esiste il template
    if (!fs.existsSync(templatePath)) {
      logger.error(
        `Template non trovato in nessuno dei luoghi: ${templatePath}`
      );
      return false;
    }

    // Copiamo il template
    fs.copyFileSync(templatePath, targetPath);
    logger.log(`‚úÖ Template copiato da: ${templatePath}`, "green");
    return true;
  } catch (error) {
    logger.error(`Errore creando template: ${error.message}`);
    return false;
  }
}

// Funzione per ricaricare il modulo dependencies-config
function reloadDependenciesConfig(projectRoot) {
  try {
    const configPath = path.join(
      projectRoot,
      "package-manager/dependencies-config"
    );
    const resolvedPath = require.resolve(configPath);

    // Clear cache to ensure fresh loading
    delete require.cache[resolvedPath];

    const depsConfig = require(configPath);
    getBaseDependencies = depsConfig.getBaseDependencies;
    getConditionalDependencies = depsConfig.getConditionalDependencies;
    getDevDependencies = depsConfig.getDevDependencies;
    getConditionalDevDependencies = depsConfig.getConditionalDevDependencies;
    getDeprecatedDependencies = depsConfig.getDeprecatedDependencies;
    getStandardScripts = depsConfig.getStandardScripts;
    getStandardTsConfig = depsConfig.getStandardTsConfig;
    getNodeEngines = depsConfig.getNodeEngines;
    logger.log(
      "‚úÖ Modulo dependencies-config ricaricato con successo!",
      "green"
    );
    return true;
  } catch (error) {
    logger.error(`Errore ricaricando modulo: ${error.message}`);
    // Usiamo funzioni di default
    getBaseDependencies = () => ({});
    getConditionalDependencies = () => ({});
    getDevDependencies = () => ({});
    getConditionalDevDependencies = () => ({});
    getDeprecatedDependencies = () => [];
    getStandardScripts = () => ({});
    getStandardTsConfig = () => ({});
    getNodeEngines = () => ({});
    return false;
  }
}

// Import moduli riorganizzati
const {
  generateDependenciesConfig,
  displayGeneratedDependencies,
  saveDependenciesConfig,
} = require("./dependencies/generator");
const { getUsedDependencies } = require("./dependencies/analyzer");
const {
  updatePackageJson,
  updateTsConfig,
  removeTslintJson,
} = require("./dependencies/updater");

// Carica configurazione progetto dinamicamente
const projectRoot = process.cwd();
// logger.log(`üîç Project root: ${projectRoot}`, "blue");
// logger.log(`üîç Project config path: ${path.join(projectRoot, "package-manager/project-config")}`, "blue");

const projectConfig = require(path.join(
  projectRoot,
  "package-manager/project-config.js"
));

// logger.log(`üîç Project config loaded:`, "blue");
// logger.log(`   - filterByPrefix: ${projectConfig.components.filterByPrefix.enabled}`, "blue");
// logger.log(`   - prefix: ${projectConfig.components.filterByPrefix.prefix}`, "blue");
// logger.log(`   - filterByStructure: ${projectConfig.components.filterByStructure.enabled}`, "blue");
// logger.log(`   - requiredFiles: ${JSON.stringify(projectConfig.components.filterByStructure.requiredFiles)}`, "blue");

// Import configurazione dipendenze dinamicamente (con fallback se non esiste)
let getBaseDependencies,
  getConditionalDependencies,
  getDevDependencies,
  getConditionalDevDependencies,
  getDeprecatedDependencies,
  getStandardScripts,
  getStandardTsConfig,
  getNodeEngines;

// Funzioni di default vuote
function initEmptyFunctions() {
  getBaseDependencies = () => ({});
  getConditionalDependencies = () => ({});
  getDevDependencies = () => ({});
  getConditionalDevDependencies = () => ({});
  getDeprecatedDependencies = () => [];
  getStandardScripts = () => ({});
  getStandardTsConfig = () => ({});
  getNodeEngines = () => ({});
}

// Inizializza con funzioni vuote di default
initEmptyFunctions();

// Funzione per verificare se dependencies-config.js √® vuoto
function isDependenciesConfigEmpty() {
  const configPath = path.join(
    process.cwd(),
    "package-manager",
    "dependencies-config.js"
  );

  if (!fs.existsSync(configPath)) {
    return true;
  }

  try {
    // Clear cache to ensure fresh loading
    const resolvedPath = require.resolve(configPath);
    delete require.cache[resolvedPath];
    const config = require(configPath);

    // Check if all main objects are empty (ignoring comments and empty values)
    const baseDepsEmpty =
      !config.BASE_DEPENDENCIES ||
      Object.keys(config.BASE_DEPENDENCIES).length === 0 ||
      Object.values(config.BASE_DEPENDENCIES).every(
        (val) =>
          (typeof val === "string" && val.trim() === "") ||
          val === null ||
          val === undefined
      );

    const conditionalDepsEmpty =
      !config.CONDITIONAL_DEPENDENCIES ||
      Object.keys(config.CONDITIONAL_DEPENDENCIES).length === 0 ||
      Object.values(config.CONDITIONAL_DEPENDENCIES).every(
        (val) =>
          !val ||
          (typeof val === "object" &&
            (!val.version || val.version.trim() === ""))
      );

    const devDepsEmpty =
      !config.DEV_DEPENDENCIES ||
      Object.keys(config.DEV_DEPENDENCIES).length === 0 ||
      Object.values(config.DEV_DEPENDENCIES).every(
        (val) =>
          (typeof val === "string" && val.trim() === "") ||
          val === null ||
          val === undefined
      );

    const conditionalDevDepsEmpty =
      !config.CONDITIONAL_DEV_DEPENDENCIES ||
      Object.keys(config.CONDITIONAL_DEV_DEPENDENCIES).length === 0 ||
      Object.values(config.CONDITIONAL_DEV_DEPENDENCIES).every(
        (val) =>
          !val ||
          (typeof val === "object" &&
            (!val.version || val.version.trim() === ""))
      );

    // Consider empty if ALL dependency objects are empty (no real dependencies)
    const hasAnyDependencies =
      !baseDepsEmpty ||
      !conditionalDepsEmpty ||
      !devDepsEmpty ||
      !conditionalDevDepsEmpty;

    // Return true if file is empty (no dependencies at all)
    return !hasAnyDependencies;
  } catch (error) {
    logger.log(
      `‚ö†Ô∏è  Errore leggendo dependencies-config.js: ${error.message}`,
      "yellow"
    );
    return true;
  }
}

// Funzione per creare readline interface
function createReadlineInterface() {
  return readline.createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false,
  });
}

// Funzione per fare domande all'utente
function askQuestion(rl, question) {
  return new Promise((resolve) => {
    rl.question(question, (answer) => {
      resolve(answer.trim());
    });
  });
}

// Funzione per mostrare le modifiche delle versioni
function showVersionChanges(
  componentDirs,
  finalBaseDeps,
  finalDevDeps,
  projectConfig,
  conditionalDeps = {},
  conditionalDevDeps = {}
) {
  logger.log("\nüìä Riepilogo modifiche versioni:", "cyan");

  const changes = {
    dependencies: {},
    devDependencies: {},
  };

  // Raccoglie le versioni attuali da tutti i componenti per il confronto
  // IMPORTANTE: Per ogni componente controlliamo se le conditional deps/devDeps 
  // sono presenti in package.json, anche se non vengono rilevate come "usate" nel codice
  // perch√© updatePackageJson le aggiorner√† comunque se sono presenti
  componentDirs.forEach((componentDir) => {
    const packageJsonPath = path.join(
      process.cwd(),
      componentDir,
      "package.json"
    );
    if (fs.existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));

      // Controlla BASE dependencies (stesso meccanismo di prima)
      Object.entries(finalBaseDeps).forEach(([name, newVersion]) => {
        const oldVersion = packageJson.dependencies?.[name];
        if (oldVersion && oldVersion !== newVersion) {
          if (!changes.dependencies[name]) {
            changes.dependencies[name] = { old: oldVersion, new: newVersion };
          }
        } else if (!oldVersion) {
          if (!changes.dependencies[name]) {
            changes.dependencies[name] = { old: null, new: newVersion };
          }
        }
      });

      // Controlla CONDITIONAL dependencies - IMPORTANTE:
      // updatePackageJson aggiorna conditional deps che sono gi√† in package.json
      // anche se non vengono rilevate come "usate" nel codice
      // Quindi controlliamo TUTTE le conditional deps dal config
      // se sono presenti in package.json del componente corrente
      Object.entries(conditionalDeps).forEach(([name, newVersion]) => {
        // Gestire sia stringhe che oggetti (per compatibilit√†)
        const configVersion = typeof newVersion === 'string' ? newVersion : (newVersion?.version || newVersion);
        if (!configVersion) return;
        
        const oldVersion = packageJson.dependencies?.[name];
        // Se il pacchetto √® gi√† presente in package.json di questo componente, 
        // verr√† aggiornato da updatePackageJson indipendentemente dall'uso nel codice
        if (oldVersion && oldVersion !== configVersion) {
          // Pacchetto presente ma con versione diversa - da aggiornare
          // Se gi√† presente in changes, aggiorna solo se la nuova versione √® diversa
          if (!changes.dependencies[name]) {
            changes.dependencies[name] = { old: oldVersion, new: configVersion };
          } else if (changes.dependencies[name].new !== configVersion) {
            // Se la versione target √® diversa da quella gi√† registrata, aggiorna
            changes.dependencies[name].new = configVersion;
          }
        }
      });

      // Controlla BASE devDependencies (stesso meccanismo di prima)
      Object.entries(finalDevDeps).forEach(([name, newVersion]) => {
        const oldVersion = packageJson.devDependencies?.[name];
        if (oldVersion && oldVersion !== newVersion) {
          if (!changes.devDependencies[name]) {
            changes.devDependencies[name] = {
              old: oldVersion,
              new: newVersion,
            };
          }
        } else if (!oldVersion) {
          if (!changes.devDependencies[name]) {
            changes.devDependencies[name] = { old: null, new: newVersion };
          }
        }
      });

      // Controlla CONDITIONAL devDependencies - IMPORTANTE:
      // updatePackageJson aggiorna conditional devDeps che sono gi√† in package.json
      // anche se non vengono rilevate come "usate" nel codice
      // Quindi controlliamo TUTTE le conditional devDeps dal config
      // se sono presenti in package.json del componente corrente
      Object.entries(conditionalDevDeps).forEach(([name, newVersion]) => {
        // Gestire sia stringhe che oggetti (per compatibilit√†)
        const configVersion = typeof newVersion === 'string' ? newVersion : (newVersion?.version || newVersion);
        if (!configVersion) return;
        
        const oldVersion = packageJson.devDependencies?.[name];
        // Se il pacchetto √® gi√† presente in package.json di questo componente, 
        // verr√† aggiornato da updatePackageJson indipendentemente dall'uso nel codice
        if (oldVersion && oldVersion !== configVersion) {
          // Pacchetto presente ma con versione diversa - da aggiornare
          // Se gi√† presente in changes, aggiorna solo se la nuova versione √® diversa
          if (!changes.devDependencies[name]) {
            changes.devDependencies[name] = {
              old: oldVersion,
              new: configVersion,
            };
          } else if (changes.devDependencies[name].new !== configVersion) {
            // Se la versione target √® diversa da quella gi√† registrata, aggiorna
            changes.devDependencies[name].new = configVersion;
          }
        }
      });
    }
  });

  // Mostra le modifiche dependencies
  if (Object.keys(changes.dependencies).length > 0) {
    logger.log("\nDependencies:", "yellow");
    Object.entries(changes.dependencies).forEach(([name, versions]) => {
      if (versions.old) {
        logger.log(`  ${name}: ${versions.old} ‚Üí ${versions.new}`, "blue");
      } else {
        logger.log(`  ${name}: [NUOVO] ‚Üí ${versions.new}`, "green");
      }
    });
  }

  // Mostra le modifiche devDependencies
  if (Object.keys(changes.devDependencies).length > 0) {
    logger.log("\nDevDependencies:", "yellow");
    Object.entries(changes.devDependencies).forEach(([name, versions]) => {
      if (versions.old) {
        logger.log(`  ${name}: ${versions.old} ‚Üí ${versions.new}`, "blue");
      } else {
        logger.log(`  ${name}: [NUOVO] ‚Üí ${versions.new}`, "green");
      }
    });
  }

  // Mostra lo stato tsconfig
  if (Object.keys(getStandardTsConfig()).length > 0) {
    logger.log("\ntsconfig.json sar√† aggiornato", "yellow");
  }

  // Ritorna true se ci sono modifiche da applicare
  const hasChanges =
    Object.keys(changes.dependencies).length > 0 ||
    Object.keys(changes.devDependencies).length > 0 ||
    Object.keys(getStandardTsConfig()).length > 0;

  return hasChanges;
}

// Funzione per formattare i log delle modifiche per componente
function logComponentChanges(changes, componentDir) {
  logger.log(`\nüì¶ ${componentDir}:`, "cyan");

  let hasAnyChanges = false;

  // Dependencies - aggiunte da BASE
  if (changes.dependencies.added.length > 0) {
    hasAnyChanges = true;
    logger.log(`   üîß Dipendenze aggiunte (BASE):`, "yellow");
    changes.dependencies.added.forEach(({ name, version }) => {
      logger.log(`      + ${name}@${version}`, "green");
    });
  }

  // Dependencies - aggiunte condizionali
  if (changes.dependencies.conditional.length > 0) {
    hasAnyChanges = true;
    logger.log(`   üîÄ Dipendenze condizionali aggiunte:`, "yellow");
    changes.dependencies.conditional.forEach(({ name, version }) => {
      logger.log(`      + ${name}@${version}`, "cyan");
    });
  }

  // Dependencies - aggiornate
  if (changes.dependencies.updated.length > 0) {
    hasAnyChanges = true;
    logger.log(`   üîÑ Dipendenze aggiornate:`, "yellow");
    changes.dependencies.updated.forEach(({ name, from, to }) => {
      logger.log(`      ${name}: ${from} ‚Üí ${to}`, "magenta");
    });
  }

  // DevDependencies - aggiunte da DEV
  if (changes.devDependencies.added.length > 0) {
    hasAnyChanges = true;
    logger.log(`   üõ†Ô∏è  Dipendenze dev aggiunte (BASE):`, "yellow");
    changes.devDependencies.added.forEach(({ name, version }) => {
      logger.log(`      + ${name}@${version}`, "green");
    });
  }

  // DevDependencies - aggiunte condizionali
  if (changes.devDependencies.conditional.length > 0) {
    hasAnyChanges = true;
    logger.log(`   üîÄ Dipendenze dev condizionali aggiunte:`, "yellow");
    changes.devDependencies.conditional.forEach(({ name, version }) => {
      logger.log(`      + ${name}@${version}`, "cyan");
    });
  }

  // DevDependencies - aggiornate
  if (changes.devDependencies.updated.length > 0) {
    hasAnyChanges = true;
    logger.log(`   üîÑ Dipendenze dev aggiornate:`, "yellow");
    changes.devDependencies.updated.forEach(({ name, from, to }) => {
      logger.log(`      ${name}: ${from} ‚Üí ${to}`, "magenta");
    });
  }

  // Rimosse deprecate
  if (changes.removed.length > 0) {
    hasAnyChanges = true;
    logger.log(`   üóëÔ∏è  Dipendenze rimosse:`, "yellow");
    changes.removed.forEach(({ name, version, type }) => {
      const typeLabel =
        type === "dependency" ? "dependencies" : "devDependencies";
      logger.log(`      - ${name}@${version} (${typeLabel})`, "red");
    });
  }

  if (!hasAnyChanges) {
    logger.log(`   ‚úÖ Nessuna modifica`, "green");
  }
}

// Funzione principale per aggiornare tutte le configurazioni
async function updateAllConfigs(scope = "all", components = []) {
  logger.log("üöÄ Avvio aggiornamento configurazioni componenti...", "cyan");

  // Clear all cached modules to ensure fresh loading
  Object.keys(require.cache).forEach((key) => {
    if (key.includes("dependencies-config") || key.includes("project-config")) {
      delete require.cache[key];
    }
  });

  const dependenciesConfigPath = path.join(
    projectRoot,
    "package-manager",
    "dependencies-config.js"
  );

  // 1. Se il file non esiste, copia il template
  if (!fs.existsSync(dependenciesConfigPath)) {
    logger.log("‚ö†Ô∏è  dependencies-config.js non trovato!", "yellow");
    logger.log("üìã Copiando template vuoto...", "cyan");

    if (createEmptyDependenciesConfig(projectRoot)) {
      logger.log("‚úÖ Template copiato!", "green");

      // Dopo aver copiato il template, verifica subito se √® vuoto
      if (isDependenciesConfigEmpty()) {
        logger.log("‚ö†Ô∏è  dependencies-config.js √® vuoto (template)!", "yellow");
        logger.log(
          "üí° Vuoi generare automaticamente dai progetti esistenti?",
          "cyan"
        );

        const rl = createReadlineInterface();
        const answer = await askQuestion(rl, "Generare? (y/N): ");

        if (answer === "y" || answer === "yes") {
          const generated = generateDependenciesConfig(projectConfig);
          displayGeneratedDependencies(generated, projectConfig);

          // Conferma salvataggio tsconfig
          if (
            generated.standardTsConfig &&
            Object.keys(generated.standardTsConfig).length > 0
          ) {
            logger.log("\n‚öôÔ∏è  TSCONFIG.JSON STANDARD trovato:", "cyan");
            logger.log(
              `   Versione TypeScript: ${generated.tsVersion}`,
              "blue"
            );
            if (generated.standardTsConfig.compilerOptions) {
              const opts = generated.standardTsConfig.compilerOptions;
              logger.log(`   Target: ${opts.target || "es2018"}`, "blue");
              logger.log(`   Module: ${opts.module || "commonjs"}`, "blue");
              logger.log(`   Strict: ${opts.strict || true}`, "blue");
            }

            const tsAnswer = await askQuestion(
              rl,
              "Salvare questa configurazione TypeScript? (y/N): "
            );
            if (tsAnswer !== "y" && tsAnswer !== "yes") {
              generated.standardTsConfig = {};
              logger.log(
                "Configurazione TypeScript non sar√† salvata",
                "yellow"
              );
            }
          }

          const saveAnswer = await askQuestion(
            rl,
            "Salvare questa configurazione? (y/N): "
          );
          if (saveAnswer === "y" || saveAnswer === "yes") {
            const saved = saveGeneratedDependencies(generated, projectRoot);
            if (saved) {
              logger.log("‚úÖ Configurazione salvata!", "green");

              // Ricarica la configurazione dopo il salvataggio
              reloadDependenciesConfig(projectRoot);

              // Chiedi conferma per procedere con l'aggiornamento
              const updateAnswer = await askQuestion(
                rl,
                "Procedere con l'aggiornamento per tutti i componenti? (y/N): "
              );
              if (updateAnswer === "y" || updateAnswer === "yes") {
                // Continua con l'aggiornamento normale
              } else {
                logger.log("‚ùå Generazione annullata", "yellow");
                rl.close();
                return false;
              }
            } else {
              logger.log("‚ùå Errore salvando configurazione", "red");
              rl.close();
              return false;
            }
          } else {
            logger.log("‚ùå Generazione annullata", "yellow");
            rl.close();
            return false;
          }
        } else {
          logger.log("‚ùå Generazione annullata", "yellow");
          rl.close();
          return false;
        }
        rl.close();
      } else {
        // Se il template non √® vuoto, mostra le istruzioni manuali
        logger.log("üìù Ora puoi riempire manualmente il file:", "cyan");
        logger.log("   package-manager/dependencies-config.js", "blue");
        logger.log("");
        logger.log("üí° Sezioni disponibili:", "cyan");
        logger.log("   1. BASE_DEPENDENCIES (sempre aggiunte)", "blue");
        logger.log(
          "   2. CONDITIONAL_DEPENDENCIES (aggiunte se utilizzate)",
          "blue"
        );
        logger.log(
          "   3. DEV_DEPENDENCIES (sempre come devDependencies)",
          "blue"
        );
        logger.log("   4. DEPRECATED_DEPENDENCIES (rimosse)", "blue");
        logger.log("");
      }
    } else {
      logger.log("‚ùå Errore copiando template", "red");
      return false;
    }
  }

  // 2. Verifica se √® vuota usando la funzione dedicata (prima di caricare)
  if (isDependenciesConfigEmpty()) {
    logger.log("‚ö†Ô∏è  dependencies-config.js √® vuoto!", "yellow");
    logger.log(
      "üí° Vuoi generare automaticamente dai progetti esistenti?",
      "cyan"
    );

    const rl = createReadlineInterface();
    const answer = await askQuestion(rl, "Generare? (y/N): ");

    if (answer === "y" || answer === "yes") {
      const generated = generateDependenciesConfig(projectConfig);
      displayGeneratedDependencies(generated, projectConfig);

      // Conferma salvataggio tsconfig
      if (
        generated.standardTsConfig &&
        Object.keys(generated.standardTsConfig).length > 0
      ) {
        logger.log("\n‚öôÔ∏è  TSCONFIG.JSON STANDARD trovato:", "cyan");
        logger.log(`   Versione TypeScript: ${generated.tsVersion}`, "blue");
        if (generated.standardTsConfig.compilerOptions) {
          const opts = generated.standardTsConfig.compilerOptions;
          logger.log(`   Target: ${opts.target || "es2018"}`, "blue");
          logger.log(`   Module: ${opts.module || "commonjs"}`, "blue");
          logger.log(`   Strict: ${opts.strict || true}`, "blue");
        }

        const confirmTs = await askQuestion(
          rl,
          "Salvare questa configurazione TypeScript? (y/N): "
        );

        if (confirmTs !== "y" && confirmTs !== "yes") {
          delete generated.standardTsConfig;
          logger.log("Configurazione TypeScript non sar√† salvata", "yellow");
        }
      }

      const confirm = await askQuestion(
        rl,
        "Salvare questa configurazione? (y/N): "
      );

      if (confirm === "y" || confirm === "yes") {
        saveDependenciesConfig(generated, projectConfig);
        logger.log("Configurazione salvata!", "green");
        reloadDependenciesConfig(projectRoot);

        // Chiedi se vuole procedere con l'aggiornamento
        const proceed = await askQuestion(
          rl,
          "Procedere con l'aggiornamento per tutti i componenti? (y/N): "
        );
        rl.close();

        if (proceed !== "y" && proceed !== "yes") {
          logger.log("üîÑ Ritorno al menu principale...", "cyan");
          return false;
        }

        logger.log("üöÄ Procedo con l'aggiornamento...", "cyan");
      } else {
        logger.log("‚ùå Generazione annullata", "yellow");
        rl.close();
        return false;
      }
    } else {
      logger.log("‚ùå Configurazione richiesta per continuare", "yellow");
      rl.close();
      return false;
    }
  } else {
    // 4. Se il file √® gi√† configurato, procedi automaticamente
    logger.log("‚úÖ dependencies-config.js trovato e configurato!", "green");
    logger.log("üöÄ Procedo con l'aggiornamento automatico...", "cyan");
  }

  // 5. Carica la configurazione dopo la verifica/generazione
  reloadDependenciesConfig(projectRoot);

  // Carica le dipendenze dopo la verifica/generazione
  const baseDeps = getBaseDependencies();
  const conditionalDeps = getConditionalDependencies();
  const devDeps = getDevDependencies();
  const conditionalDevDeps = getConditionalDevDependencies();

  // Non aggiungere pi√π tutte le dipendenze condizionali globalmente
  // Verranno processate per ogni componente individualmente
  const finalBaseDeps = { ...baseDeps };
  const finalDevDeps = { ...devDeps };

  // Ottieni configurazioni standard
  const standardScripts = getStandardScripts();
  const standardTsConfig = getStandardTsConfig();
  const nodeEngines = getNodeEngines();
  const deprecatedDeps = getDeprecatedDependencies();

  // Ottieni componenti con filtrazione
  const { getComponentDirectories } = require("./dependencies/analyzer");
  let componentDirs = getComponentDirectories(projectConfig);

  // logger.log(`üîç Trovati ${componentDirs.length} componenti:`, "blue");
  // componentDirs.forEach((dir, index) => {
  //   logger.log(`   ${index + 1}. ${dir}`, "blue");
  // });

  // Applica filtrazione basata su scope e components
  if (scope === "single" && components.length > 0) {
    componentDirs = componentDirs.filter((dir) => components.includes(dir));
    // logger.log(`üîç Dopo filtro single: ${componentDirs.length} componenti`, "blue");
  } else if (scope === "exclude" && components.length > 0) {
    componentDirs = componentDirs.filter((dir) => !components.includes(dir));
    // logger.log(`üîç Dopo filtro exclude: ${componentDirs.length} componenti`, "blue");
  }

  if (componentDirs.length === 0) {
    logger.log("‚ùå Nessun componente trovato", "red");
    return false;
  }

  // Conferma aggiornamento tsconfig
  if (Object.keys(standardTsConfig).length > 0) {
    logger.log(
      "\ntsconfig.json sar√† aggiornato secondo STANDARD_TSCONFIG",
      "yellow"
    );

    const rl = createReadlineInterface();
    const confirmTsUpdate = await askQuestion(
      rl,
      "Continuare l'aggiornamento tsconfig.json per tutti i componenti? (y/N): "
    );
    rl.close();

    if (confirmTsUpdate !== "y" && confirmTsUpdate !== "yes") {
      logger.log("Aggiornamento tsconfig.json saltato", "yellow");
      // Salta l'aggiornamento tsconfig
      Object.keys(standardTsConfig).forEach(
        (key) => delete standardTsConfig[key]
      );
    }
  }

  // Mostra riepilogo delle dipendenze che verranno applicate
  logger.log("\nüìã Riepilogo configurazione dipendenze:", "cyan");
  logger.log("", "reset");

  if (Object.keys(finalBaseDeps).length > 0) {
    logger.log("üîß DIPENDENZE BASE che verranno aggiunte:", "yellow");
    Object.entries(finalBaseDeps).forEach(([name, version]) => {
      logger.log(`   ${name}: ${version}`, "blue");
    });
    logger.log("", "reset");
  }

  if (Object.keys(conditionalDeps).length > 0) {
    logger.log(
      "üîÄ DIPENDENZE CONDIZIONALI che verranno aggiunte (se utilizzate):",
      "yellow"
    );
    Object.entries(conditionalDeps).forEach(([name, version]) => {
      logger.log(`   ${name}: ${version}`, "blue");
    });
    logger.log("", "reset");
  }

  if (Object.keys(finalDevDeps).length > 0) {
    logger.log("üõ†Ô∏è  DIPENDENZE DEV che verranno aggiunte:", "yellow");
    Object.entries(finalDevDeps).forEach(([name, version]) => {
      logger.log(`   ${name}: ${version}`, "blue");
    });
    logger.log("", "reset");
  }

  if (Object.keys(conditionalDevDeps).length > 0) {
    logger.log(
      "üîÄ DIPENDENZE DEV CONDIZIONALI che verranno aggiunte (se utilizzate):",
      "yellow"
    );
    Object.entries(conditionalDevDeps).forEach(([name, version]) => {
      logger.log(`   ${name}: ${version}`, "blue");
    });
    logger.log("", "reset");
  }

  // Mostra tsconfig standard se disponibile
  const previewTsConfig = getStandardTsConfig();
  if (previewTsConfig && Object.keys(previewTsConfig).length > 0) {
    logger.log("‚öôÔ∏è  TSCONFIG.JSON STANDARD che verr√† applicato:", "yellow");
    logger.log(
      `   Target: ${previewTsConfig.compilerOptions?.target || "es2018"}`,
      "blue"
    );
    logger.log(
      `   Module: ${previewTsConfig.compilerOptions?.module || "commonjs"}`,
      "blue"
    );
    logger.log(
      `   Strict: ${previewTsConfig.compilerOptions?.strict || true}`,
      "blue"
    );
    logger.log("", "reset");
  }

  // Mostra il riepilogo delle modifiche delle versioni solo se ci sono modifiche
  // Passa anche conditional deps per controllare le versioni se presenti in package.json
  const hasChanges = showVersionChanges(
    componentDirs,
    finalBaseDeps,
    finalDevDeps,
    projectConfig,
    conditionalDeps,
    conditionalDevDeps
  );

  if (!hasChanges) {
    logger.log("\n‚úÖ Tutti i componenti sono gi√† aggiornati!", "green");
    logger.log("üîô Premi INVIO per tornare al menu principale...", "cyan");
    const pauseRl = createReadlineInterface();
    await askQuestion(pauseRl, "");
    pauseRl.close();
    return true;
  }

  let updatedCount = 0;
  let skippedCount = 0;
  let errorCount = 0;
  const totalCount = componentDirs.length;

  componentDirs.forEach((componentDir) => {
    const fullPath = path.join(process.cwd(), componentDir);

    // Debug: mostra il percorso completo
    // logger.log(`   üìÅ Percorso completo: ${fullPath}`, "blue");
    const packageJsonPath = path.join(fullPath, "package.json");
    // logger.log(`   üìÑ package.json: ${packageJsonPath}`, "blue");
    // logger.log(`   ‚úÖ Esiste: ${fs.existsSync(packageJsonPath)}`, "blue");

    // Verifica se il componente esiste
    if (!fs.existsSync(fullPath)) {
      logger.error(`‚ùå Directory non trovata: ${fullPath}`, "red");
      errorCount++;
      return;
    }

    // Verifica se package.json esiste
    if (!fs.existsSync(packageJsonPath)) {
      logger.error(`‚ùå package.json non trovato in ${componentDir}`, "red");
      errorCount++;
      return;
    }

    // Analizza dipendenze condizionali per questo componente specifico
    const { analyzeDependencyUsage } = require("./dependencies/analyzer");
    const usedConditionalDeps = analyzeDependencyUsage(
      fullPath,
      conditionalDeps,
      projectConfig
    );
    const componentConditionalDeps = {};
    usedConditionalDeps.forEach((dep) => {
      componentConditionalDeps[dep.name] = dep.version;
    });

    // Analizza dipendenze dev condizionali per questo componente specifico
    const usedConditionalDevDeps = analyzeDependencyUsage(
      fullPath,
      conditionalDevDeps,
      projectConfig
    );
    const componentConditionalDevDeps = {};
    usedConditionalDevDeps.forEach((dep) => {
      componentConditionalDevDeps[dep.name] = dep.version;
    });

    // –î–æ–¥–∞—Ç–∏ conditional deps/devDeps, —è–∫—ñ –≤–∂–µ —î –≤ package.json –∑ —ñ–Ω—à–æ—é –≤–µ—Ä—Å—ñ—î—é
    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, "utf8"));

    // –î–ª—è conditional deps
    Object.entries(conditionalDeps).forEach(([name, configVersionValue]) => {
      // Gestire sia stringhe che oggetti (per compatibilit√†)
      const configVersion = typeof configVersionValue === 'string' 
        ? configVersionValue 
        : (configVersionValue?.version || configVersionValue);
      if (!configVersion) return;
      
      const currentVersion = packageJson.dependencies?.[name];
      if (currentVersion && currentVersion !== configVersion) {
        // –í–∂–µ —î –≤ package.json –∑ —ñ–Ω—à–æ—é –≤–µ—Ä—Å—ñ—î—é - –¥–æ–¥–∞—Ç–∏ –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
        if (!componentConditionalDeps[name]) {
          componentConditionalDeps[name] = configVersion;
        }
      }
    });

    // –î–ª—è conditional devDeps
    Object.entries(conditionalDevDeps).forEach(([name, configVersionValue]) => {
      // Gestire sia stringhe che oggetti (per compatibilit√†)
      const configVersion = typeof configVersionValue === 'string' 
        ? configVersionValue 
        : (configVersionValue?.version || configVersionValue);
      if (!configVersion) return;
      
      const currentVersion = packageJson.devDependencies?.[name];
      if (currentVersion && currentVersion !== configVersion) {
        // –í–∂–µ —î –≤ package.json –∑ —ñ–Ω—à–æ—é –≤–µ—Ä—Å—ñ—î—é - –¥–æ–¥–∞—Ç–∏ –¥–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
        if (!componentConditionalDevDeps[name]) {
          componentConditionalDevDeps[name] = configVersion;
        }
      }
    });

    const packageResult = updatePackageJson(
      fullPath,
      projectConfig,
      finalBaseDeps,
      finalDevDeps,
      deprecatedDeps,
      standardScripts,
      nodeEngines,
      componentConditionalDeps,
      componentConditionalDevDeps
    );

    // Formattiamo i log per componente
    if (packageResult.changes) {
      logComponentChanges(packageResult.changes, componentDir);
    }

    const tsConfigSuccess = updateTsConfig(
      fullPath,
      projectConfig,
      standardTsConfig
    );

    // Aggiungiamo log per tsconfig.json se √® stato aggiornato
    if (tsConfigSuccess && Object.keys(standardTsConfig).length > 0) {
      // Il logging √® gi√† in updateTsConfig, ma possiamo aggiungere qui se necessario
    }

    const tslintSuccess = removeTslintJson(fullPath, projectConfig);

    if (packageResult.success && tsConfigSuccess && tslintSuccess) {
      if (packageResult.changes) {
        updatedCount++;
      } else {
        skippedCount++;
      }
    } else {
      errorCount++;
      logger.log(`   ‚ùå Errore aggiornamento ${componentDir}`, "red");
    }
  });

  logger.log(`\nüìä Risultato:`, "cyan");
  logger.log(`   ‚úÖ Aggiornati: ${updatedCount}/${totalCount}`, "green");
  logger.log(`   ‚è≠Ô∏è  Senza modifiche: ${skippedCount}/${totalCount}`, "blue");
  logger.log(
    `   ‚ùå Errori: ${errorCount}/${totalCount}`,
    errorCount > 0 ? "red" : "green"
  );

  if (errorCount === 0) {
    logger.log(
      "\nüéâ Tutte le configurazioni aggiornate con successo!",
      "green"
    );
    // Chiedi se installare i pacchetti ora
    try {
      const projectConfigPath = path.join(
        process.cwd(),
        "package-manager",
        "project-config.js"
      );
      if (fs.existsSync(projectConfigPath)) {
        const projectConfig = require(projectConfigPath);

        const rl = createReadlineInterface();
        const answer = await askQuestion(
          rl,
          "\nVuoi installare i pacchetti adesso? (y/N): "
        );
        rl.close();

        if (answer === "y" || answer === "yes") {
          if (
            projectConfig.workspace?.enabled &&
            projectConfig.workspace?.initialized
          ) {
            logger.log(
              "\nüîÑ Workspace rilevato - installazione pacchetti centralizzata...",
              "cyan"
            );
            const {
              installAllComponentsWorkspace,
            } = require("./operations/workspace-install");
            const workspaceSuccess = installAllComponentsWorkspace(
              projectConfig,
              "normal"
            );
            if (workspaceSuccess) {
              logger.success("‚úÖ Pacchetti installati tramite workspace!");
            } else {
              logger.warning("‚ö†Ô∏è  Errore durante l'installazione workspace");
            }
          } else {
            logger.log("\nüîÑ Installazione pacchetti standard...", "cyan");
            const { getComponentDirectories } = require("./utils/common");
            const components = getComponentDirectories(projectConfig);
            let installSuccess = 0;
            for (const component of components) {
              try {
                const componentPath = path.join(process.cwd(), component);
                const {
                  installPackagesStandard,
                } = require("./operations/standard-install");
                const success = installPackagesStandard(
                  componentPath,
                  "normal",
                  projectConfig
                );
                if (success) installSuccess++;
              } catch (error) {
                logger.warning(
                  `‚ö†Ô∏è  Errore installazione ${component}: ${error.message}`
                );
              }
            }
            if (installSuccess === components.length) {
              logger.success("‚úÖ Tutti i pacchetti installati con successo!");
            } else {
              logger.warning(
                `‚ö†Ô∏è  Installati ${installSuccess}/${components.length} componenti`
              );
            }
          }
        } else {
          logger.info("‚è≠Ô∏è  Installazione pacchetti saltata su richiesta");
        }
      }
    } catch (error) {
      logger.warning("‚ö†Ô∏è  Errore durante l'installazione pacchetti");
      logger.warning(`   ${error.message}`);
    }
  } else {
    logger.log(
      "\n‚ö†Ô∏è  Alcune configurazioni non sono state aggiornate. Controlla gli errori sopra.",
      "yellow"
    );
  }

  // Pausa per permettere all'utente di leggere i risultati
  logger.log("\nüîô Premi INVIO per tornare al menu principale...", "cyan");
  const pauseRl = createReadlineInterface();
  await askQuestion(pauseRl, "");
  pauseRl.close();

  return errorCount === 0;
}

// Avvio script
if (require.main === module) {
  updateAllConfigs().then((success) => {
    process.exit(success ? 0 : 1);
  });
}

module.exports = {
  updateAllConfigs,
  showVersionChanges,
  createEmptyDependenciesConfig,
  reloadDependenciesConfig,
  isDependenciesConfigEmpty,
};
